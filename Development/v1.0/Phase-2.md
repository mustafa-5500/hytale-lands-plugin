### Phase 2: Managers
- [âœ“] Implement `SelectionManager` (player corner tracking)
    ### Overview: SelectionManager Implementation
    SelectionManager: The function to track the corners that a player selects when creating a selection to claim. Creates a region object from the selection. The region object just needs to be given two vector3i objects, it will then create a selection using the max and min coordinates from those two vector3i object. So all the SelectionManager needs to do is get the selection from the player and create a region for land claim with it.

        Concerns: Overlapping regions in a landclaim will cause blocks to be counted multiple times in the volume for the land claim, so when adding the region to the land claim we need to split it so it is not counting multiple times over. Optimization potential, we can optomize the space taken by a land claim by merging regions. So if multiple regions form a large cuboid region then we can represent it as one region, reducing the number of vector3i objects to be stored. Though optomization would be for the future, since it probably isnt that space inefficeint.

        Implementation: The manager stores the two corners that players have selected, so we will have two maps, for player id and corner. There will be set position grammars for each corner, and a boolean for when the selection has been completed. Then create a new region, The region constructor will already create the region using the max corners, so we just need to give our selected corners to it. Then the created region will be passed back to the selection command which will send it to the land manager to be added to a land.

- [ ] Implement `LandManager` (CRUD, position lookup)
    ### Overview: LandManager Implementation
    LandManager: Manage the interaction between the Land commands and listeners and the Land objects. For example will implement regions becoming part of a land, including edge cases for overlapping region and how to split them into non overlapping regions. As well as optomizations such as merging regions into single large cuboid regions, to reduce the reduce the space taken by the land object.

        Concerns: Land name can be changed, however land id cannot be changed, so we should store land references by id, and for references by name we need to update it if the name ever changes. For region validation, checking every land will be unoptimal, instead we should check based on proximity. So we could calculate the 'max' length of the region by finding the distance between the min and max corner of that region, and use that to narrow our land search based on proximity. So we can take the center of a region and apply the 'max' length/2 around it, and if other regions are in those positions then it potentially overlaps with a land, telling us to do a more deterministic check.

        Overlapping New Region Problem: When adding regions it would be really easy for players to overlap the new region with existing parts of their claim, so rather than refuse overlapping regions, or accept them and risk multi counting volume. We will want to break up the new region into sub-regions, such that the sub-regions do not overlap with any existing region in the land. This problem is the cuboid subtraction problem, we want to subtract the cuboid that is overlapping, leaving a set of cuboid sub regions from the new region which is not overlapping. The overlap area of the cuboids, the intersection cuboid, can be found using an inequality. The inequality is just finding the maximum corner, between the two overlapping cuboids minimum corners, and finding the minimum corner between the two maximum corners. These two corners will represent the intersection cuboid. Then we need to subtract the intersection cuboid from the new region. 

            Cuboid Intersection: To check that a cuboid is intersecting we need to understand a quality of the cuboid, The max corner of a cuboid is greater than every block in the cuboid, in terms of coordinate location, and the min corner of the cuboid is less than every block in the cuboid, in terms of coordinate. Overlapping cuboids will mix this property, so that the min corner and max corner of each cuboid will have the same property with the other cuboid min and max corner. so min1 is less than max2, and max1 is greater than min2, if both are true for all axis, then the cuboids overlap/intersect.

            Cuboid Subtraction: The high level idea is that we split the cuboid based of the planes on each axis created by the subtracting cuboid. so we would create upto six new cuboid from the subtraction. We want to compare the max to the mins and vice versa for the cuboid and the intersecting subtraction region. Note: drawing this out with 2D squares helps with understanding. Note: for each axis we shift the previous axis using the intersection regions coordinate values, this prevents the split off cuboid regions from overlapping eachother.
                Case 1, min_x < intersection_min_x: Create a new cuboid where; The max_x is the intersection_min_x value.
                Case 2, intersection_max_x < max_x: Create a new cuboid where; The min_x is the intersection_max_x value.
                Case 3, min_y < intersection_min_y: Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, the max_y is the intersection_min_y value.
                Case 4, intersection_max_y < max_y: Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, the min_y is the intersection_max_y value.
                Case 5, min_z < intersection_min_z: Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, min_y is the intersection_min_y value, max_y is the intersection_max_y value, max_z is the intersection_min_z value.
                Case 6, intersection_max_z < max_z:  Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, min_y is the intersection_min_y value, max_y is the intersection_max_y value, min_z is the intersection_max_z value.

                Concern: what if the subtraction leave an empty region, so there is no leftover volume, we can add a check if the created regions have zero or negative volume then it is an invalid region. After more consideration, since the cases use non-inclusive inequalities, so no equal to, the case of the subtraction leaving an empty cuboid is covered, therefore we wont be storing useless empty cuboid regions.

            Cuboid Merge: Given a list of Cuboid regions, we want to combine adjacent regions to form larger cuboids which represent the same volume as the previous list, purpose is to reduce space and optomize lookup. The algorithm will be implemented iteratively, using 2 nested for loops, to then check if every pair of regions can be merged, then merging the pair, thereby removing 2 regions and adding 1 region.

                Merging criteria: The cuboid regions must be adjacent along one axis. The cuboid regions must fill the same plane along the other two regions. So essentially the regions must be a shifted version of eachother along one axis. We can check that the plane is the same along the other two axis by checking if the min and max corners of the regions are the same along two axis. We can assume that the Regions will not be overlapping, since the list of regions in a Lands object should not be overlapping, but we can do an extra check.

                Optimizations: We can only check regions which are close together, rather than every region.

            Region Claiming: High level idea, add a region into the list of regions for the land. However, we want to maintain the property of a land that the region are all non overlapping, therefore we will loop through every region in the land, if it overlaps the region then we will subtract the overlapping existing region from the new region. This will split the new region into upto 6 new sub-regions, the region subtraction algorithm guarantees that the resulting split up regions will not overlap, therefore we can continue the for loop, but now compare the upto 6 new regions. Therefore to facilitate this before we iterate the for loop we will need to put the new region into a list.

                Concern: Since Regions can be as small as a single block, there is potential for space inefficiency with storing every single region for a land. To optomize the space taken by the Land's region list, we will have to implement a Region merge function, which only merges regions if they are adjacent, and two axis are the same, therefore they are a full cuboid extension along one axis, therefore merging the two cuboids will result in another cuboid, which can be represented with 2 vector3i objects, rather than 4. This function will be O(n^2), two nested for loops, so it will only be run after a region has been claimed. Realistic it won't be O(n^2) since not every region in a land will fulfill the 2 requirements needed for the cuboid merge.

            Region Unclaiming: High level idea, let players select a region, make it so that the selected region's volume is subtracted from the volume represented by the list of region in the land object.

                Side-note: When we add subclaims, we will make them not effected by Land unclaiming. The purpose of subclaim behaviour will be to allow non-government type playstyles to exist. The mechanical difference between a subclaim and Land claim will be that subclaims cannot declare war, they cannot expand into another subclaim or land claim, however land claims can expand over sub claims. This can give power of the land claim over the subclaim, such as taxes. Subclaims outside of land claims will have to pay upkeep as well, however we will make it less upkeep than a land claim. Subclaims will be smaller than land claims, you will need more people in a subclaim for it to be bigger, or have the subclaim be created in a land claim for it to be bigger.

                Side-note: In the future if we create a king of the hill war mode, we would want land claims to be split into "districts" so one land claim can end up being governed by multiple players or nations, with de-facto ruler of a land claim either controling a majority of the volume or controlling a "Capital" district, such as governing building. Now the problem with this is that districts would have to be defined by the builds and story telling about them, relying on human decision making for districts can cause bias. The mechanical way to do this will be to generate a model which can detect what the building in a city are supposed to be, both by the blocks on the ground and written lore about them, that would also mean we would want a way to link lore to certain coordinates, perhaps even certain claims or subclaims.

                Concerns: Lands must be continuous volumes, so we must make sure that when unclaiming a region the rest of the land is continuous. Either we reject unclaims which will leave a part of the land non-continuous, for the player experience this can get annoying since the lands can potentially take really odd shapes, and all it takes is one block to end up non-continuous to prevent an unclaim, which would be annoying/challenging for players to find. More so when in the future we add upkeep and claim decay, most likely subtracting blocks which are furthest from the center of the region. Since the land is made up of a list of regions, an unclaim region can split the list, therefore we wont be able to determine which region is non-continuous or not since we will be given essentially two list of regions. But how will we determine the two list of regions? The region subtract function subtract the regions and gives a set of regions which are not overlapping, but the new list are not guaranteed to be adjacent. In the claim function we can overlook this case since the subtracted volume is taken up by the new claimed region.

                    Solution: We warn the player that the land claim will be split by the unclaiming, giving the player the list of splits resulting from the unclaim. The splits will show their volume and central position. We can use the volume of each split to figure out which split to keep as the claim, the split with the largest volume is the one to be kept.
                
                Problem: Subtracting a Cuboid region from the list of cuboid regions might result in multiple disconnected volumes, however a land must always be connected. The lands regions are represented as a list, so we will want to create new lists from the groups of continuous regions split from the main land after the subtraction.

                    We could represent the regions as a tree/graph. So each region will also point to its adjacent regions. In Java when we have lists of object, it is actually a list of references/pointers to those objects, not storing each object in that list. So we will add a new property to the Region structure, which is a pointer to the adjacent regions for that structure, this means we need to maintain these pointers whenever regions are claimed or unclaimed. Correction, we will use sets to store the pointers for adjacent regions, since for the merge function we can merge the two sets and not store duplicate pointers which will optimize space and lookup.

                        Region Creation: Since this could be a stand alone region, the adjacency set is created as an empty hashset.
                        Region adjacency Check: We'll keep the inequality based adjacency check since it is constant time, so therefore lookup would not be helpful, plus for the set to be populated it relies on the inequality based adjacency check.
                        Region overlap: The adjacency set will have the property of only pointing to regions directly adjacent to other regions, not including overlapping regions. Therefore Region overlap does not deal with the adjacency set.
                        Region Contains: Inequality checking if a block position is within a region, does not require information about adjacency, does not effect adjacency of the region, so the adjacency set remains untouched.
                        Region Intersection: Given a region, create the intersection region between this region and the other region, does not require knowledge about region adjacency, does not effect region adjacency.
                        Region Subtraction: Given a region, subtract its volume and create a new list of regions representing the remaining volume. Since we are creating a new list of regions from an existing region, these new regions are not stand alone, and will have to reflect the adjacency of the old region. Furthermore they need to reflect the adjacency between themselves. So we will need to iterate through the list to see which of them are adjacent to each other, and iterate through the adjacency set of the original to check which of the new regions will be adjacent to the others.
                        Region isSamePlaneAs: Boolean check whether one face/plane of a region is the same as another region, meaning the two are shifts and multiples of eachother along an axis. Does not require knowledge about adjacency, nor does it effect adjacency.
                        Region merge: creates a new region which is the merge between this and other. This will effect the adjacency set of the new region, since it is not a stand alone region, it is created from the previous regions, therefore it will retain the adjacency of the previous regions. This is done by performing a union between the previous region's adjacency set.
                        Region getVolume: Multiplies the lengths of the region, does not require adjacency nor does it effect adjacency.
                        Land Claiming a region: Since the new region is a newly constructed region selected by the player, it will have an empty adjacency set, so we need to loop through all the regions in the land to check for adjacency and populate the new region's adjacency set. Also if the new region is split, the split regions will check the already set adjacency region in the region subtract function, however for a robust check each new region will also iterate through the rest of the region in the land, this might be unoptimal, so in the future we can switch the for loop to optimize the number of iterations.
                        Land Region storage: Regions used to stored as list for the land object, however after further consideration we changed it to Sets or Regions, this will prevent the same region object from being duplicated in the set, so when we calculate total volume of a land, duplicate regions wont cause inaccuracies.

                    Now we have a Set of Regions that belong to a land, each region has a Set of Regions which are adjacent to it, the adjacency set is maintained for all Region effecting functions. Now for the problem when subtracting a volume from the set of regions in a land causes the total volume to be split into multiple parts. How can we collect the regions for each part of the volume? Currently our Regions represent nodes in a graph, so we will need to use a search algorithm. We can iterate through our regions in the land, for each region we run a graph search, however the graph search also marks regions that have been seen, so the graph search fully explores the graph from a region and marks them, perhaps by putting them in a set. This set now represents a split volume in the land. Now our loop will continue iterating, checking if each region has been put into a split set yet. If it hasnt then that region is part of a new split that we need to search through using graph search. This algorithm will only be O(n) if we assume that set look up is constant time. Even with the graph search, each search will only iterate through each node once, therefore taking O(m) with m being the size of the split set. The sum of all the split sets is n, the size of the original set. We'll implement BFS, since our goal is to find every node in a split, furthermore the set of regions in a split is connected to eachother so depth doesnt really have a meaning other than how many cuboid regions you moved through before reaching a dead end.

                    To Implement the added response from the player, we will need to make a copy of the land's list of region's, as this will allow us to undo changes if the player changes their mind after seeing the splits that will be lost and the split that will remain. The copy will have to be a deep copy, since not only are we adding and removing regions after the subtraction, the region subtract function also effects the adjacency set of the regions. Wait our copy creates new set of adjacency regions from the original, now the problem is that, the corners are never mutated but that set is, and specifically that both the region and the reference are effected. 

                    Region copying: Since we need to copy regions for the unclaim function, the region copy function will also copy every adjacent region, which will essentially copy the entire region group volume that it is part of. So for the land function to copy its region set, if the land is fully continuous this it will only call the region copy function once, then check if there is an equivalent region in that set, a region with either the same object hash, or with the same corners. This will require a recursive graph search function to go through every connected region and make a copy of it.

                        Implementation: Base case, there are no adjacent regions, or there are no adjacent regions which have not been mapped yet. For the Region class its copy function will only return that region object, but it will create a deep copy of every adjacent region from that region. Add a function to explore the adjacent regions and give back the set, so a BFS function.

                    Side-note: We never removed a region after it got subtracted right? When using subtract region in the claim function, we are subtracting from the new region which should not have an empty adjacency set. However we dont cover how to remove a region from the adjacency set, so the graph, properly.
                    Side-note: Since we are now copying Regions, we need a better way of detecting equal regions, that would be using their corners, so we will implement an equals() function for the region object, so that we dont accidentally track copies of the same volume.

        Implementation: We'll add Land constructor, destructor, and getters for the land. As well as put a player land selection. This will implement the create, delete, and read portions of the manager. For the update portion we will need to ensure that the land objects are valid, so not just putting the given data into the land object. For example when claiming a region we need to check that the region is valid, so adjacent to existing region, not overlapping another land, and if it overlaps a region in the land that we are adding it to, then we subdivide the region. 
- [ ] Add chunk-based spatial indexing for performance