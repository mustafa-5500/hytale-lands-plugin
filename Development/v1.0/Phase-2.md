### Phase 2: Managers
- [âœ“] Implement `SelectionManager` (player corner tracking)
    ### Overview: SelectionManager Implementation
    SelectionManager: The function to track the corners that a player selects when creating a selection to claim. Creates a region object from the selection. The region object just needs to be given two vector3i objects, it will then create a selection using the max and min coordinates from those two vector3i object. So all the SelectionManager needs to do is get the selection from the player and create a region for land claim with it.

        Concerns: Overlapping regions in a landclaim will cause blocks to be counted multiple times in the volume for the land claim, so when adding the region to the land claim we need to split it so it is not counting multiple times over. Optimization potential, we can optomize the space taken by a land claim by merging regions. So if multiple regions form a large cuboid region then we can represent it as one region, reducing the number of vector3i objects to be stored. Though optomization would be for the future, since it probably isnt that space inefficeint.

        Implementation: The manager stores the two corners that players have selected, so we will have two maps, for player id and corner. There will be set position grammars for each corner, and a boolean for when the selection has been completed. Then create a new region, The region constructor will already create the region using the max corners, so we just need to give our selected corners to it. Then the created region will be passed back to the selection command which will send it to the land manager to be added to a land.

- [ ] Implement `LandManager` (CRUD, position lookup)
    ### Overview: LandManager Implementation
    LandManager: Manage the interaction between the Land commands and listeners and the Land objects. For example will implement regions becoming part of a land, including edge cases for overlapping region and how to split them into non overlapping regions. As well as optomizations such as merging regions into single large cuboid regions, to reduce the reduce the space taken by the land object.

        Concerns: Land name can be changed, however land id cannot be changed, so we should store land references by id, and for references by name we need to update it if the name ever changes. For region validation, checking every land will be unoptimal, instead we should check based on proximity. So we could calculate the 'max' length of the region by finding the distance between the min and max corner of that region, and use that to narrow our land search based on proximity. So we can take the center of a region and apply the 'max' length/2 around it, and if other regions are in those positions then it potentially overlaps with a land, telling us to do a more deterministic check.

        Overlapping New Region Problem: When adding regions it would be really easy for players to overlap the new region with existing parts of their claim, so rather than refuse overlapping regions, or accept them and risk multi counting volume. We will want to break up the new region into sub-regions, such that the sub-regions do not overlap with any existing region in the land. This problem is the cuboid subtraction problem, we want to subtract the cuboid that is overlapping, leaving a set of cuboid sub regions from the new region which is not overlapping. The overlap area of the cuboids, the intersection cuboid, can be found using an inequality. The inequality is just finding the maximum corner, between the two overlapping cuboids minimum corners, and finding the minimum corner between the two maximum corners. These two corners will represent the intersection cuboid. Then we need to subtract the intersection cuboid from the new region. 

            Cuboid Intersection: To check that a cuboid is intersecting we need to understand a quality of the cuboid, The max corner of a cuboid is greater than every block in the cuboid, in terms of coordinate location, and the min corner of the cuboid is less than every block in the cuboid, in terms of coordinate. Overlapping cuboids will mix this property, so that the min corner and max corner of each cuboid will have the same property with the other cuboid min and max corner. so min1 is less than max2, and max1 is greater than min2, if both are true for all axis, then the cuboids overlap/intersect.

            Cuboid Subtraction: The high level idea is that we split the cuboid based of the planes on each axis created by the subtracting cuboid. so we would create upto six new cuboid from the subtraction. We want to compare the max to the mins and vice versa for the cuboid and the intersecting subtraction region. Note: drawing this out with 2D squares helps with understanding. Note: for each axis we shift the previous axis using the intersection regions coordinate values, this prevents the split off cuboid regions from overlapping eachother.
                Case 1, min_x < intersection_min_x: Create a new cuboid where; The max_x is the intersection_min_x value.
                Case 2, intersection_max_x < max_x: Create a new cuboid where; The min_x is the intersection_max_x value.
                Case 3, min_y < intersection_min_y: Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, the max_y is the intersection_min_y value.
                Case 4, intersection_max_y < max_y: Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, the min_y is the intersection_max_y value.
                Case 5, min_z < intersection_min_z: Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, min_y is the intersection_min_y value, max_y is the intersection_max_y value, max_z is the intersection_min_z value.
                Case 6, intersection_max_z < max_z:  Create a new cuboid where; The min_x is the intersection_min_x value, the max_x is the intersection_max_x value, min_y is the intersection_min_y value, max_y is the intersection_max_y value, min_z is the intersection_max_z value.

                Concern: what if the subtraction leave an empty region, so there is no leftover volume, we can add a check if the created regions have zero or negative volume then it is an invalid region. After more consideration, since the cases use non-inclusive inequalities, so no equal to, the case of the subtraction leaving an empty cuboid is covered, therefore we wont be storing useless empty cuboid regions.

            Region Claiming: High level idea, add a region into the list of regions for the land. However, we want to maintain the property of a land that the region are all non overlapping, therefore we will loop through every region in the land, if it overlaps the region then we will subtract the overlapping existing region from the new region. This will split the new region into upto 6 new sub-regions, the region subtraction algorithm guarantees that the resulting split up regions will not overlap, therefore we can continue the for loop, but now compare the upto 6 new regions. Therefore to facilitate this before we iterate the for loop we will need to put the new region into a list.

        Implementation: We'll add Land constructor, destructor, and getters for the land. As well as put a player land selection. This will implement the create, delete, and read portions of the manager. For the update portion we will need to ensure that the land objects are valid, so not just putting the given data into the land object. For example when claiming a region we need to check that the region is valid, so adjacent to existing region, not overlapping another land, and if it overlaps a region in the land that we are adding it to, then we subdivide the region. 
- [ ] Add chunk-based spatial indexing for performance